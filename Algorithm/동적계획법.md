#### 2021-01-29 작성  
  
  

# 동적계획법(Dynamic Programming)

- `분할정복`과 같은 접근방식을 의미한다. 다만 동적 계획법과 분할정복의 차이가 발생하는 부분은 '문제를 나누는 방식'이다. 동적계획법에서 어떤 부분문제(sub problem)는 두 개 이상의 문제를 푸는 데 사용될 수 있기 때문에 이 문제의 답을 여러번 계산하는 대신 한번만 계산하고 계산 결과를 재활용함으로써 속도 향상을 꾀한다. 이렇게 한번 계산한 값을 저장해뒀다 재활용하는 최적화기법을 
`메모이제이션(memoization)`이라고 한다.

**피보나치 수**를 예로 들어서 설명하겠다.

![image](https://user-images.githubusercontent.com/64109506/106286769-5a4d7780-6289-11eb-85d1-2427c43defb1.png)
> 제0항을 0, 제1항을 1로 두고, 둘째 번 항부터는 바로 앞의 두 수를 더한 수로 놓는다. 1번째 수를 1로, 2번째 수도 1로 놓고, 3번째 수부터는 바로 앞의 두 수를 더한 수로 정의하는 게 좀더 흔하게 알려져 있는 피보나치 수열이다. 이 둘 사이에는 시작점이 다르다는 정도를 빼면 사실상 동일하다. 그 중에서 16 번째 항까지만 나열해 보자면 (0), 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987
이렇게 간다. (나무위키)

피보나치 수열은 대표적인 **재귀(recursion)문제**이다. 그러나 재귀로 피보나치 수열을 풀게 되면 아래와 같이 **중복된 연산을 반복**한다. `fib(6)`을 구하기 위해 `fib(1)`이나 `fib(2)`가 연산되는 것을 확인할 수 있다. 

**DP**를 이용해서 문제를 풀게 되면 이러한 부분에서 시간절약을 할 수 있다. 이미 **한번 구해놓은 값은 다시 연산하여 구하지 않고 기존에 저장된 값에서 가져오는 것**이다. 이렇게 되면 **불필요한 연산이 줄기 때문에 속도가 매우 향상**된다.

![image](https://user-images.githubusercontent.com/64109506/106286773-5c173b00-6289-11eb-879b-cd8d3bdbfb13.png)

파이썬 코드로 살펴보자.

**재귀**

```python
n = int(input())
fibo(n)

def fibo(n):
	if n < 2:
		return 1
	else:
		return fibo(n-1) + fibo(n-2)
```

**DP**

```python
n = int(input())
fibo = [0 for _ in range(n)]
fibo[0] = 1
fibo[1] = 1

for i in range(2,n):
	fibo[i] = fibo[i-1] + fibo[i-2]
```

---

# 참고자료

- 동적계획법 : [https://dojinkimm.github.io/algorithm/2019/10/17/dp-1.html](https://dojinkimm.github.io/algorithm/2019/10/17/dp-1.html)
- 알고리즘 문제 해결 전략 1
